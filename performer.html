<!doctype html>
<html>
    <head>
        <meta charset="UTF-8" />
        <title>Performer</title>
        <script src="phaser.min.js"></script>
        <script src="utilities.js"></script>
    </head>
    <body>

    <script type="text/javascript">
    /* global Phaser */
    /* global onDragStart */
    /* global onDragStop */
    /* global getAllUrlParams */
    /* global DrawGrid */
    /* global DrawIconPalette */
    /* global PlaceEventIcon */
    /* global getCurrentTime */
    /* global determinePartNumberFromY */
    /* global convertYToPercentageInPart */
    /* global convertEventYToAbsoluteY */
    /* global isComposer */
    (function() { // Begin scoping function
    var debug = false;
    var homeBaseUrl = "http://ec2-52-36-206-120.us-west-2.compute.amazonaws.com:4747";
    var partNumber = 0;
    var LastEventIdProcessed = 0.0;
    var globals;
    window.onload = function() {
        var game = new Phaser.Game(800, 600, Phaser.AUTO, '', 
                { create: create });
        
        function create () {
            
            game.load.onLoadComplete.add(loadComplete, this);
    
            game.time.events.repeat(Phaser.Timer.SECOND, 1000000000, GetGlobalEvent, this);
            game.stage.backgroundColor = "0800ff";
            game.stage.disableVisibilityChange = true;
            
            if(isComposer()){
                game.debug.text( "Composer = true", 300, 300 );
            }else{
                game.debug.text( "Composer = false", 300, 300 );
            }
            var partNumber = 0;
            var partIdentifier = getAllUrlParams().part;
            if (typeof partIdentifier != 'undefined'){
                partNumber=Number(partIdentifier);
            }
            if (partNumber==0)  // score
            { 
                var xhr = new XMLHttpRequest();
                xhr.onreadystatechange = function() {
                    if (xhr.readyState == XMLHttpRequest.DONE) {
                        globals = JSON.parse(xhr.responseText);
                        if (debug==true){
                            game.debug.text( "global number of parts = "+globals.parts, 100, 280 );
                        }
                        DrawGrid(game,globals.parts); // draw with # of parts in globals.parts
                        for (let i = 0; i < globals.icons.length; i++) {
                           game.load.image(globals.icons[i].name,'Images/'+globals.icons[i].fileName);
                        }
                         game.load.start();
                    }
                };
                xhr.open('GET', homeBaseUrl + "/globals", true);
                xhr.send(null);
            }else{
                xhr = new XMLHttpRequest();
                xhr.onreadystatechange = function() {
                    if (xhr.readyState == XMLHttpRequest.DONE) {
                        globals = JSON.parse(xhr.responseText);
                        game.debug.text( "parts = "+globals.parts, 100, 280 );
                        DrawGrid(game,0);
                        for (let i = 0; i < globals.icons.length; i++) {
                           game.load.image(globals.icons[i].name,'Images/'+globals.icons[i].fileName);
                        }
                         game.load.start();
                    }
                };
                xhr.open('GET', homeBaseUrl + "/globals", true);
                xhr.send(null);
            }
            
            function loadComplete() { 
                if (isComposer())
                {// only draw the palette if this is a 'composer'
                    DrawIconPalette(game,globals);
                }
            }

            function GetGlobalEvent() {
                var xhr = new XMLHttpRequest();
                xhr.onreadystatechange = function() {
                    if (xhr.readyState == XMLHttpRequest.DONE) {
                        var event = JSON.parse(xhr.responseText);
                        if (event.id > LastEventIdProcessed){
                            LastEventIdProcessed=event.id;
                            if (debug==true){
                                game.debug.text("name="+event.icon+"["+event.x+","+event.y+"] Part :" + event.part, 100, 400 );
                            }
                            let y = 0;
                            if (partNumber<1){ //showing score
                                if (debug == true){
                                    game.debug.text( "SCORE", 100, 100 );
                                }
                                y = convertEventYToAbsoluteY(event.y,event.part, globals.parts, game.height);
                                if (debug==true){
                                    game.debug.text("converted y = "+ y, 100,600);
                                }
                               PlaceEventIcon(game,event.icon,event.x,y);
                            }else{ // showing single part
                                if (event.part==partNumber){
                                    y = event.y * game.height;
                                    PlaceEventIcon(game,event.icon,event.x,y);
                                }
                                if (debug == true){
                                    game.debug.text( "PART "+ partNumber, 100, 100 );
                                }
                            }
                        }
                    }
                };
                xhr.open('GET', homeBaseUrl + "/getEvents", true);
                xhr.send(null);
            }   
            
        }
    
        function IconPlaced(pointer, spriteName) {
            let x = Number((pointer.x).toFixed(2));
            let y = pointer.y;
      
            var xhr = new XMLHttpRequest();
            xhr.onreadystatechange = function() {
                if (xhr.readyState == XMLHttpRequest.DONE) {
                } 
            };
            var convertedY = convertYToPercentageInPart(y,globals.parts,game.height);
            var placedPart = determinePartNumberFromY(y,globals.parts,game.height);
            var reportUrl = homeBaseUrl 
                + "/newEvent?x="+ x + "&y=" + convertedY + "&part=" + placedPart + "&icon=" + spriteName;
            xhr.open('GET',reportUrl , true);
            xhr.send(null);
        }
            
        function onDragStop(sprite, pointer) {
            game.debug.text( "dragStop at: ["+pointer.x+","+pointer.y+"]", 300, 400 );
            if (partNumber<1){  // when score only
                IconPlaced(pointer,sprite.key);
                sprite.destroy();
                DrawIconPalette(game,globals);
            }
        }
        
        function DrawIconPalette(game,globals){
          let n = globals.icons.length;
          let rows = (n/2);
          let x1 = .80 * game.width;
         
          let gfx = game.add.graphics(0,0);
          gfx.lineStyle(10, 0x33FF00);
          /* draw the vertical lines for palette area*/
          gfx.moveTo(x1,0);
          gfx.lineTo(x1,game.height);
          let x2 = .90 * game.width;
          gfx.moveTo(x2,0);
          gfx.lineTo(x2,game.height);
          // draw vertical lines for each row of palette
          if (rows>0){ // only draw if score (when score, pwrts > 0 )
            var step;
            for (step = 1; step <=rows; step++) 
            {
                gfx.moveTo(x1,step * (game.height/rows));
                let icon1 = globals.icons[(step-1)*2];
                let sprite = game.add.sprite(x1,(step * (game.height/rows)), icon1.name);
                sprite.y -= sprite.height;
                sprite.inputEnabled = true;
                sprite.input.enableDrag(false);
                game.physics.enable(sprite, Phaser.Physics.ARCADE);
              
                sprite.events.onDragStop.add(onDragStop,this);
                
                let icon2 = globals.icons[((step-1)*2)+1];
                let sprite2 = game.add.sprite(x2,(step * (game.height/rows)), icon2.name);
                sprite2.y -= sprite2.height;
                sprite2.inputEnabled = true;
                sprite2.input.enableDrag(false);
                
                sprite2.events.onDragStop.add(onDragStop,this);
                game.physics.enable(sprite2, Phaser.Physics.ARCADE);
                if (step<rows){ // draw one less line
                  gfx.lineTo(game.width,step * (game.height/rows));
                }
            }
        }
    }
            
    };
    })();         // End scoping function
    </script>

    </body>
</html>